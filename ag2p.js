import { DeliverooApi } from "@unitn-asa/deliveroo-js-client";
import { onlineSolver, PddlExecutor, PddlProblem, Beliefset, PddlDomain, PddlAction } from "@unitn-asa/pddl-client";
import fs from 'fs';

// A requirement for the project is to integrate some planner.
// Here the planner is integrated as a path_finder so it replaces the 
// go_to action used in all the other plan classes with a plan generated by the planner.

// 0 for no pddl, 1 for pddl. Switching it to 1 will use pddl for any movement to a specific tile.
const use_pddl = 0;

function read_pddl_File ( path ) {
    return new Promise( (res, rej) => {
        fs.readFile( path, 'utf8', (err, data) => {
            if (err) rej(err)
            else res(data)
        })
    })
}
const domain = await read_pddl_File('domain-d.pddl' );

// Define executors for actions in your plan
const executors = [
    { name: 'left', executor: () => client.move('left')},
    { name: 'right', executor: () => client.move('right')},
    { name: 'up', executor: () => client.move('up')},  
    { name: 'down', executor: () => client.move('down')},
];

class PathPlanning {

    constructor() {
        this.agent_id = '';
        this.objects = '';
        this.init = '';
        this.init0 = '';
        this.initializeMap();
        this.isPlanning = false;
    }

    // The initializeMap function is used to create the objects and initial state of the PDDL problem.
    // It firsts recreate internally the map from the tiles received from the server.
    // After that 'converts' it to PDDL objects and initial state.
    // It gets called only once since map stays the same during the game.
    initializeMap() {

        console.log('MAP INITIALIZATION');
        const blockedTiles = map.blkd();
        const spawnableTiles = map.spwn();
        const deliveryTiles = map.deliv();
        const matrix = Array.from({ length: map.height }, () => Array(map.width).fill(3));
        blockedTiles.forEach(tile => {
            matrix[tile.x][tile.y] = 0;
            });
        spawnableTiles.forEach(tile => {
            matrix[tile.x][tile.y] = 1;
            });
        deliveryTiles.forEach(tile => {
            matrix[tile.x][tile.y] = 2;
            });
        this.map = matrix;
        for (let y = 0; y < this.map.length; y++) {
            for (let x = 0; x < this.map[y].length; x++) {
                const tileName = `t${x}_${y}`;
                this.objects += `tile ${tileName} `;
                switch (this.map[x][y]) {

                    //0 = blocked (empty or not_tile), 1 = walkable spawning, 2 = delivery, 3 = walkable non-spawning.
                    case 0:
                        this.init0 += `(blocked ${tileName})`;
                        break;
                    case 1: 
                        //this.init0 += `(spawn ${tileName})`;
                        break;
                    case 3:
                        break;
                    case 2:
                        this.init0 += `(delivery ${tileName})`;
                        break;
                }

                // Add directional relationships
                if (x > 0) this.init0 += `(right t${x-1}_${y} ${tileName})(left ${tileName} t${x-1}_${y})`;
                if (y > 0) this.init0 += `(up t${x}_${y-1} ${tileName})(down ${tileName} t${x}_${y-1})`;
            }
        }
        this.init += this.init0;
    }

    // called every time a new target is set.
    // important is the reset of init to init0, otherwise the init would grow indefinitely, including all previous targets.
    updateTarget(agentID, startX, startY, targetX, targetY) {

            this.agent_id = `id_${agentID}`;
            this.objects += `me ${this.agent_id} `
            this.init = `(me ${this.agent_id})` + this.init0;

            this.startX = startX;
            this.startY = startY;
            this.init += `(at ${this.agent_id} t${this.startX}_${this.startY})`;

            this.targetX = targetX;
            this.targetY = targetY;
    }   


    generateProblemDefinition() {

        const goal = `at ${this.agent_id} t${this.targetX}_${this.targetY}`;
        console.log('Goal:', goal);

        var pddlProblem = new PddlProblem(
            'grid-path-planning',
            this.objects,
            this.init,
            goal
        )
        let problem = pddlProblem.toPddlString();
        return problem
      }
  

    async planAndExecute() {

        if (this.isPlanning) {
            console.log('A plan is already in execution. Please wait or cancel the current plan before starting a new one.');
            // here it woould be possible to drop the new plan or to queue it or to cancel the current one.
            return; // Exit if a plan is currently being executed
            }
        this.isPlanning = true; // Mark as planning started

        try {

            const problem = this.generateProblemDefinition();
            // const domain = await read_pddl_File('domain-d.pddl' );  
            // domain read at the beginning of the file, so it is not read every time a new plan is generated.     
            const plan = await onlineSolver(domain, problem);
            const pddlExecutor = new PddlExecutor(...executors);

            // await otherwise the plan is not executed because rest of the code is faster?
            await pddlExecutor.exec(plan);

        } catch (error) {
            console.error('Error during path planning:', error);
        } finally {
            this.isPlanning = false; // Reset planning state
    
        }
    }
}

// Things emerging from the 1st challenge:
// - is spawnable? something about parcels always spawning in same place --> DONE
// - remove condition if other agent is too close? --> DONE
// - collisions if path is size=1? Add a ruke --> >TODO (if needed)


const client1 = new DeliverooApi(

    //'http://localhost:8080/?name=SVM',''

    //'https://deliveroojs3.onrender.com/',
    //'http://rtibdi.disi.unitn.it:8080',
    //'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6Ijc1M2EzMjhmYTg0IiwibmFtZSI6IlNWTS1Sb2JvdCIsImlhdCI6MTcxNTY3OTgzM30.ArlxYLnx3TQP9sYbSlimeK8VWaEPjM3BqpseiKPeHoo'


    'http://localhost:8080',
    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImJiNWJiNWEyYjA3IiwibmFtZSI6IlNWTSIsImlhdCI6MTcxMjY0OTM2NH0.trqXmE29PmO4AVgVWWZjSrxj4CqLS1pqk3aQnnSsl-4'

)


const client2 = new DeliverooApi(

    //'http://localhost:8080/?name=SVM_2',client1.token

    'http://localhost:8080', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjM1ZDg0YWMwN2RhIiwibmFtZSI6IlNWTV8yIiwiaWF0IjoxNzE5OTM0MDMwfQ.Tbr2ZjeVqBdUFaCZgxg_8t1WtNns9d7lCIb5oc_Pj_s'
    
)

var client = client2;


// instantiate the path planning, this way it is available for all the plans and we can initialize
// the map only once.
var pathPlanning;


function distance( {x:x1, y:y1}, {x:x2, y:y2}) {
    const dx = Math.abs( Math.round(x1) - Math.round(x2) )
    const dy = Math.abs( Math.round(y1) - Math.round(y2) )
    return dx + dy;
}

function nearestDelivery(x4, y4) {
    const delivs0 = Array.from( map.tiles.values() ).filter( ({delivery}) => delivery )
    const distances = []
    const delivs = map.deliv()

    for (const d of delivs){   
        distances.push(distance( {x:d.x, y:d.y}, {x:x4, y:y4}))
    }
    const minDistanceIndex = distances.indexOf(Math.min(...distances));
    return delivs[minDistanceIndex];
}

const me = { carrying: new Map() };
client.onYou( ( {id, name, x, y, score} ) => {
    me.id = id
    me.name = name
    me.x = x
    me.y = y
    me.score = score
    
} )

const me1 = { carrying: new Map() };
client1.onYou( ( {id, name, x, y, score} ) => {
    me1.id = id
    me1.name = name
    me1.x = x
    me1.y = y
    me1.score = score
    
} )

const me2 = { carrying: new Map() };
client2.onYou( ( {id, name, x, y, score} ) => {
    me2.id = id
    me2.name = name
    me2.x = x
    me2.y = y
    me2.score = score
    
} )


const map = {
    width:undefined,
    height:undefined,
    tiles: new Map(),
    add: function ( tile ) {
        const {x, y} = tile;
        return this.tiles.set( x+1000*y, tile );
    },
    xy: function (x, y) {
        return this.tiles.get( x+1000*y )
    },
    spwn: function () {
        return Array.from( this.tiles.values() ).filter( ({parcelSpawner}) => parcelSpawner )
    },
    deliv: function () {
        return Array.from( this.tiles.values() ).filter( ({delivery}) => delivery )
    },
    blkd: function () {
        return Array.from( this.tiles.values() ).filter( ({blocked}) => blocked )
    }
};

client.onMap( (width, height, tiles) => {
    map.width = width;
    map.height = height;
    for (const t of tiles) {
        map.add( t );
    }
    pathPlanning = new PathPlanning(me.id);
} )


client.onTile( (x, y, delivery) => {
    map.add( {x, y, delivery} );
} )

client.onNotTile( ( x, y ) => { 
    map.add( {x, y, blocked: true} );
} )

var AGENTS_OBSERVATION_DISTANCE
var PARCELS_OBSERVATION_DISTANCE
var MOVEMENT_DURATION
var PARCEL_DECADING_INTERVAL

client.onConfig( (config) => {
    AGENTS_OBSERVATION_DISTANCE = config.AGENTS_OBSERVATION_DISTANCE;
    PARCELS_OBSERVATION_DISTANCE = config.PARCELS_OBSERVATION_DISTANCE;
    MOVEMENT_DURATION = config.MOVEMENT_DURATION;
    PARCEL_DECADING_INTERVAL = config.PARCEL_DECADING_INTERVAL//== '1s' ? 1000 : 1000000;
} );


const agents = new Map();
client.onAgentsSensing( ( sensed_agents ) => {
    for ( const {id, name, x, y, score} of sensed_agents ) {
        agents.set(id, {id, x, y} );
    }
    for ( const [id, {x, y}] of agents.entries() ) {
        if ( distance (me, {x, y}) < AGENTS_OBSERVATION_DISTANCE && ! sensed_agents.find( (sensed) => id == sensed.id ) )
        agents.delete(id);
    }
} );


const parcels = new Map();
client.onParcelsSensing( async ( perceived_parcels ) => {
    let new_parcel_sensed = false;
    for (const p of perceived_parcels) {
        if ( ! parcels.has(p.id) )
            new_parcel_sensed = true;
        parcels.set( p.id, p)
        if ( p.carriedBy == me.id ) {
            me.carrying.set( p.id, p );
        }
    }
    for ( const [id,p] of parcels.entries() ) {
        if ( ! perceived_parcels.find( p=>p.id==id ) ) {
            parcels.delete( id ); 
            me.carrying.delete( id );
        }
    }
} )


var reset1 = true;

client.onParcelsSensing( parcels => {

    const options = []
    for (const parcel of parcels.values()) {

        const d5 = []
        for (const a of agents){
            d5.push(distance({x:parcel.x,y:parcel.y},{x:a[1].x,y:a[1].y}))
        }

        // if ( ! parcel.carriedBy && distance({x:parcel.x,y:parcel.y},{x:me.x,y:me.y}) <= Math.min(...d5)) {
        // removed the condition on distance from agents. From challenge it was observed that was not good: 
        // agents are not moving, or standing still or if other agents have a similar behaviour, then the condition is not useful.

        if ( ! parcel.carriedBy) {
            options.push( [ 'go_pick_up', parcel.x, parcel.y, parcel.id]);
        }
    }

    /** Options filtering*/
    let best_option;
    let nearest = Number.MAX_VALUE;
    for (const option of options) {
        if ( option[0] == 'go_pick_up' ) {
            let [go_pick_up,x,y,id] = option;
            let current_d = distance( {x, y}, me )
            if ( current_d < nearest ) {
                best_option = option
                nearest = current_d
            }
        }
    }

    /** Best option is selected*/
    if ( best_option ){
        reset1 = true;
        myAgent.push( best_option );
    }
    else if (reset1){

        reset1 = false;

        if (me.carrying.size > 0){
            myAgent.push( ['deliv1', nearestDelivery(me.x,me.y).x, nearestDelivery(me.x,me.y).y])
        }
        else myAgent.push( ['expl_rand', me.x, me.y]);
        //else myAgent.push( ['expl3', me.x, me.y]);
    }
    else {
        reset1 = true;
    }
} )

const beliefset = new Map();

//client.onAgentsSensing( callb => {console.log('agent sensing')})
//client.onYou( agentLoop )


/** Intention revision loop */
class IntentionRevision {

    #intention_queue = new Array();
    get intention_queue () {
        return this.#intention_queue;
    }

    async loop ( ) {
        while ( true ) {
            
            // Consumes intention_queue if not empty
            if ( this.intention_queue.length > 0 ) {
                console.log( 'intentionRevision.loop', this.intention_queue.map(i=>i.predicate) );
            
                // Current intention
                const intention = this.intention_queue[0];
                
                // Is queued intention still valid? Do I still want to achieve it?
                let id = intention.predicate[2]
                let p = parcels.get(id)
                if ( p && p.carriedBy ) {
                    console.log( 'Skipping intention because no more valid', intention.predicate )
                    continue;
                }

                // Start achieving intention
                await intention.achieve()
                // Catch eventual error and continue
                .catch( error => {
                    // console.log( 'Failed intention', ...intention.predicate, 'with error:', ...error )
                } );
                // Remove from the queue
                this.intention_queue.shift();
            }
            // Postpone next iteration at setImmediate
            await new Promise( res => setImmediate( res ) );
        }
    }

    // async push ( predicate ) { }
    log ( ...args ) {
        console.log( ...args )
    }
}

class IntentionRevisionQueue extends IntentionRevision {

    async push ( predicate ) {
        // Check if already queued
        if ( this.intention_queue.find( (i) => i.predicate.join(' ') == predicate.join(' ') ) )
            return; // intention is already queued

        console.log( 'IntentionRevisionReplace.push', predicate );
        const intention = new Intention( this, predicate );
        this.intention_queue.push( intention );
    }
}

class IntentionRevisionReplace extends IntentionRevision {

    async push ( predicate ) {

        // Check if already queued
        const last = this.intention_queue.at( this.intention_queue.length - 1 );
        if ( last && last.predicate.join(' ') == predicate.join(' ') ) {
            return; // intention is already being achieved
        }
        
        console.log( 'IntentionRevisionReplace.push', predicate );
        const intention = new Intention( this, predicate );
        this.intention_queue.push( intention );
        
        // Force current intention stop 
        if ( last ) {
            last.stop();
        }
    }
}


/**Start intention revision loop*/

// const myAgent = new IntentionRevisionQueue();
const myAgent = new IntentionRevisionReplace();

myAgent.loop();



/**Intention*/
class Intention {

    // Plan currently used for achieving the intention 
    #current_plan;
    // This is used to stop the intention
    #stopped = false;
    get stopped () {
        return this.#stopped;
    }
    stop () {
        // this.log( 'stop intention', ...this.#predicate );
        this.#stopped = true;
        if ( this.#current_plan)
            this.#current_plan.stop();
    }
    /**#parent refers to caller*/
    #parent;
    /** predicate is in the form ['go_to', x, y]*/
    get predicate () {
        return this.#predicate;
    }
    #predicate;

    constructor ( parent, predicate ) {
        this.#parent = parent;
        this.#predicate = predicate;
    }

    log ( ...args ) {
        if ( this.#parent && this.#parent.log )
            this.#parent.log( '\t', ...args )
        else
            console.log( ...args )
    }

    #started = false;
    /*** Using the plan library to achieve an intention*/
    async achieve () {
        // Cannot start twice
        if ( this.#started)
            return this;
        else
            this.#started = true;

        // Trying all plans in the library
        for (const planClass of planLibrary) {

            // if stopped then quit
            if ( this.stopped ) throw [ 'stopped intention', ...this.predicate ];
            // if plan is 'statically' applicable
            if ( planClass.isApplicableTo( ...this.predicate ) ) {
                // plan is instantiated
                this.#current_plan = new planClass(this.parent);
                this.log('achieving intention', ...this.predicate, 'with plan', planClass.name);
                // and plan is executed and result returned
                try {
                    const plan_res = await this.#current_plan.execute( ...this.predicate );
                    this.log( 'succesful intention', ...this.predicate, 'with plan', planClass.name, 'with result:', plan_res );
                    return plan_res
                // or errors are caught so to continue with next plan
                } catch (error) {
                    this.log( 'failed intention', ...this.predicate,'with plan', planClass.name, 'with error:', ...error );
                }
            }
        }
        // if stopped then quit
        if ( this.stopped ) throw [ 'stopped intention', ...this.predicate ];
        // no plans have been found to satisfy the intention
        // this.log( 'no plan satisfied the intention ', ...this.predicate );
        reset1 = true;
        this.#current_plan.stop();;
        throw ['no plan satisfied the intention ', ...this.predicate ];
        
    }

}

/** Plan library */
const planLibrary = [];
class Plan {
    // This is used to stop the plan
    #stopped = false;
    stop () {
        // this.log( 'stop plan' );
        this.#stopped = true;
        for ( const i of this.#sub_intentions ) {
            i.stop();
        }
    }
    get stopped () {
        return this.#stopped;
    }
    /*** #parent refers to caller*/
    #parent;
    constructor ( parent ) {
        this.#parent = parent;
    }
    log ( ...args ) {
        if ( this.#parent && this.#parent.log )
            this.#parent.log( '\t', ...args )
        else
            console.log( ...args )
    }
    // this is an array of sub intention. Multiple ones could eventually being achieved in parallel.
    #sub_intentions = [];
    async subIntention ( predicate ) {
        const sub_intention = new Intention( this, predicate );
        this.#sub_intentions.push( sub_intention );
        return await sub_intention.achieve();
    }
}


class GoPickUp extends Plan {

    static isApplicableTo ( go_pick_up, x, y, id ) {
        return go_pick_up == 'go_pick_up';
    }
    async execute ( go_pick_up, x, y ) {

        //client = client1;

        if (distance( {x:me1.x, y:me1.y}, {x:x, y:y}) <= distance( {x:me2.x, y:me2.y}, {x:x, y:y}) ){
            client = client1;
        } else {
            client = client2;
        }
        console.log(me1.x, me1.y, me2.x, me2.y, x, y);


        if ( this.stopped ) throw ['stopped'];
        await this.subIntention( ['go_to', x, y] );
        if ( this.stopped ) throw ['stopped'];
        await client.pickup()
        if ( this.stopped ) throw ['stopped'];
        client = client1;
        return true;
    }
}

class GoDeliver extends Plan {

    static isApplicableTo ( go_pick_up, x, y,) {
        return go_pick_up == 'deliv1';
    }
    async execute ( go_pick_up, x, y ) {
        if ( this.stopped ) {reset1=true; throw ['stopped'];}
        await this.subIntention( ['go_to', x, y] );
        await client.putdown();
        if ( this.stopped ) {reset1=true; throw ['stopped'];}
        reset1=true;
        return true;
    }
}


// use_pddl == 0 will use the BlindMove, == 1 will use the PDDL_Move.
class PDDL_Move extends Plan {

    static isApplicableTo ( go_to, x, y ) {
        return go_to == (use_pddl === 1 ? 'go_to' : 'go_to2');
    }

    async execute ( go_to, x, y ) {

        // Round x and y to the closest integer because otherwise they wouldn't match the tile names in pddl objects.

        //const pathPlanning = new PathPlanning(me.id);
        console.log('PDDL_Move', 'from', Math.round(me.x), Math.round(me.y), 'to', Math.round(x), Math.round(y));
        pathPlanning.updateTarget(me.id, Math.round(me.x), Math.round(me.y), Math.round(x), Math.round(y));
        await pathPlanning.planAndExecute();

        return true; 
    }
    
}

class BlindMove extends Plan {

    static isApplicableTo ( go_to, x, y ) {
        return go_to == (use_pddl === 0 ? 'go_to' : 'go_to2');
    }

    async execute ( go_to, x, y ) {
        

        while ( me.x != x || me.y != y ) {
            if ( this.stopped ) throw ['stopped']; 
            let status_x = false;
            let status_y = false; 

            if ( x > me.x ){
                status_x = await client.move('right');
            }

            else if ( x < me.x ){
                status_x = await client.move('left');   
            }      

            if (status_x) {
                me.x = status_x.x;
                me.y = status_x.y;
            }
            if ( this.stopped ) throw ['stopped'];
            if ( y > me.y )
                status_y = await client.move('up')

            else if ( y < me.y )
                status_y = await client.move('down')

            if (status_y) {
                me.x = status_y.x;
                me.y = status_y.y;
            }      
            if ( ! status_x && ! status_y) {
                //this.log('stucked');
                await this.backtrack();
                //throw 'stucked';
            } else if ( me.x == x && me.y == y ) {
                console.log('target reached');
            }          
        }
        return true;
    }

    // simple backtracking mechanism introduced to avoid getting stuck:
    // it will perform n (=10) random moves and then continue with the original path.

    async backtrack() {
        console.log('BACKTRACKING')
        for (let i = 0; i < 10; i++) {
            const d = ['right', 'left', 'up', 'down'][Math.floor(Math.random() * 4)];
            await client.move(d);
          }

        // Continue with the original path
        await this.execute(go_to, x, y);
    }
}

class ExplRandom extends Plan {

    static isApplicableTo ( expl_rand, x, y, id ) {
        return expl_rand == 'expl_rand';
    }
    async execute ( go_pick_up, x, y ) {

        client = client2;
        // before challenge1 it would pick a random tile
        var x_r0 = Math.floor(Math.random() * (map.width-1 - 0 + 1)) + 0;
        var y_r0 = Math.floor(Math.random() * (map.height-1 - 0 + 1)) + 0;

        // --> picks a random spawnable tile (possible to add closer spawnable tile or other conditions)
        let randomIndex = Math.floor(Math.random() * map.spwn().length);
        let selectedPoint = map.spwn()[randomIndex];
        var x_r = selectedPoint.x;
        var y_r = selectedPoint.y;

        console.log('ExplRandom:', 'from' , me.x, me.y, 'to', x_r, y_r);

        if ( this.stopped ) throw ['stopped'];
        await this.subIntention( ['go_to', x_r, y_r] );
        if ( this.stopped ) throw ['stopped'];
        await client.pickup()
        if ( this.stopped ) throw ['stopped'];
        return true;
    }
}

// ExplFar3 is a plan that will move the agent to the farthest corner of the map. Currently not used
class ExplFar3 extends Plan {

    static isApplicableTo ( expl3, xm, ym ) {
        return expl3 == 'expl3';
    }
    
    async execute ( go_pick_up, xm, ym ) {

        var c_xmax = map.width-1;
        var c_ymax = map.height-1;
        var values6 = {
        c1 : distance( {x:0, y:0}, {x:xm, y:ym}),
        c2 : distance( {x:0, y:c_ymax}, {x:xm, y:ym} ),
        c3 : distance( {x:c_xmax, y:0}, {x:xm, y:ym} ),
        c4 : distance( {x:c_xmax, y:c_ymax}, {x:xm, y:ym} )
        }
        const maxValueName = Object.keys(values6).reduce((maxName, currentName) => {
             return values6[maxName] > values6[currentName] ? maxName : currentName;
             }, '');   
        var values7 = {
        c1 : [0,0],
        c2 : [0,c_ymax],
        c3 : [c_xmax,0],
        c4 : [c_xmax,c_ymax]
        }
        var x2 = values7[maxValueName][0];
        var y2 = values7[maxValueName][1];

        if ( this.stopped ) {reset1=true; throw ['stopped'];}
        await this.subIntention( ['go_to', x2, y2] );
        await client.putdown();
        if ( this.stopped ) {reset1=true; throw ['stopped'];}
        reset1 = true;
        prev_expl_p = [xm,ym]
        return true;
    }
}


// perform a random different move
class RandomMove extends Plan {
    static isApplicableTo ( random1) {
        return random1 == 'random1';
    }
    async execute () {
        let tried = [];
        var previous = 'right';
        while ( tried.length < 4 ) {
            let current = { up: 'down', right: 'left', down: 'up', left: 'right' }[previous] // backward
            if ( tried.length < 3 ) { // try ahead or turn (before going backward)
                //current = [ 'up', 'right', 'down', 'left' ].filter( d => d != current )[ Math.floor(Math.random()*3) ];
                current = [ 'up', 'right', 'down', 'left' ][ Math.floor(Math.random()*4) ];
                //this way it goes full randomS
            }
            if ( ! tried.includes(current) ) {  
                if ( await client.move( current ) ) {
                    console.log( 'moved', current );
                    previous = current;
                    break; // moved, continue
                }   
                tried.push( current );   
            }  
        }
        if ( tried.length == 4 ) {
            console.log( 'stucked' );
            await client.timer(1000); // stucked, wait 1 sec and retry
        } 
        return true;
    }
}


// Plan classes are added to plan library 
planLibrary.push( GoPickUp )
planLibrary.push( BlindMove )
planLibrary.push( RandomMove )
planLibrary.push( GoDeliver )
planLibrary.push( ExplFar3 )
planLibrary.push( ExplRandom )
planLibrary.push( PDDL_Move )

