import { DeliverooApi } from "@unitn-asa/deliveroo-js-client";
import { onlineSolver, PddlExecutor, PddlProblem, Beliefset, PddlDomain, PddlAction } from "@unitn-asa/pddl-client";
import fs from 'fs';
import { parseArgs, findIsolatedSections, find_my_isolated_section } from './functions2.js';
const args = parseArgs(process.argv.slice(2));

//const when_idle = args.when_idle ? args.when_idle : 1;
//const multi_agents = args.multi_agents ? args.multi_agents : 0;
//const split_map = args.split_map ? args.split_map : 1;
//const use_pddl = args.use_pddl ? args.use_pddl : 0;


// flagging variables
const when_idle = 1;        
const multi_agents = 0;
var split_map = 0;          
const use_pddl = 0;
// when_idle: 1 for random exploration, 0 for standing still.
// multi_agents: 1 for multi-agent, 0 for single-agent. setting it to 0 will: not split the map, not comunicate with the other agent.
// split_map: 1 for split map, 0 for single map.
// use_pddl: 0 for no pddl, 1 for pddl. Switching it to 1 will use pddl for any movement to a specific tile.




// A requirement for the project is to integrate some planner.
// Here the planner is integrated as a path_finder so it replaces the 
// go_to action used in all the other plan classes with a plan generated by the planner.


function read_pddl_File ( path ) {
    return new Promise( (res, rej) => {
        fs.readFile( path, 'utf8', (err, data) => {
            if (err) rej(err)
            else res(data)
        })
    })
}
const domain = await read_pddl_File('domain-d.pddl' );

const executors = [
    { name: 'left', executor: () => client.move('left')},
    { name: 'right', executor: () => client.move('right')},
    { name: 'up', executor: () => client.move('up')},  
    { name: 'down', executor: () => client.move('down')},
];

var isolatedSections;
var isolated_single = 0;

class PathPlanning {

    constructor() {
        this.agent_id = '';
        this.objects = '';
        this.init = '';
        this.init0 = '';
        this.initializeMap();
        this.isPlanning = false;
    }

    // The initializeMap function is used to create the objects and initial state of the PDDL problem.
    // It first recreate internally the map from the tiles received from the server.
    // After that, it 'converts' it to PDDL objects and initial state.
    // It gets called only once since map stays the same during the game.
    async initializeMap() {

        await client.move('right');
        const blockedTiles = map.blkd();
        const spawnableTiles = map.spwn();
        const deliveryTiles = map.deliv();
        const matrix = Array.from({ length: map.height }, () => Array(map.width).fill(3));
        blockedTiles.forEach(tile => {
            matrix[tile.x][tile.y] = 0;
            });
        spawnableTiles.forEach(tile => {
            matrix[tile.x][tile.y] = 1;
            });
        deliveryTiles.forEach(tile => {
            matrix[tile.x][tile.y] = 2;
            });


        // inside the initializeMap function, we also check for isolated sections and if the agent is inside one of them.
        // If agent is inside one, some things changes. If both agents are inside the same isolated section, some other things change.
        isolatedSections = findIsolatedSections(matrix);
        console.log('Isolated sections:', isolatedSections);

        var isInIsolatedSection = find_my_isolated_section(isolatedSections, me.x, me.y);
        console.log('Agent1: Is my position inside isolated sections?', isInIsolatedSection.length > 0);

        if(isInIsolatedSection.length > 0) {
            var reply;
            if (multi_agents == 1){
                reply = await client.ask( '35d84ac07da', {
                    hello: 'isolated_section',
                    is_sec: isInIsolatedSection,
                } );
            } else {
                reply = false;
            }
        
            if (reply) {
                myAgent.push( ['isolated_section', isInIsolatedSection]);
            } else { isolated_single = 1; myAgent.push( ['isolated_section_single', isInIsolatedSection]);}
        }

        this.map = matrix;

        for (let y = 0; y < this.map.length; y++) {
            for (let x = 0; x < this.map[y].length; x++) {
                const tileName = `t${x}_${y}`;
                this.objects += `tile ${tileName} `;
                switch (this.map[x][y]) {

                    //0 = blocked (empty or not_tile), 1 = walkable spawning, 2 = delivery, 3 = walkable non-spawning.
                    case 0:
                        this.init0 += `(blocked ${tileName})`;
                        break;
                    case 1: 
                        //this.init0 += `(spawn ${tileName})`;
                        break;
                    case 3:
                        break;
                    case 2:
                        this.init0 += `(delivery ${tileName})`;
                        break;
                }
                // Add directional relationships
                if (x > 0) this.init0 += `(right t${x-1}_${y} ${tileName})(left ${tileName} t${x-1}_${y})`;
                if (y > 0) this.init0 += `(up t${x}_${y-1} ${tileName})(down ${tileName} t${x}_${y-1})`;
            }
        }
        this.init += this.init0;
    }
    // called every time a new target is set.
    // important is the reset of init to init0, otherwise the init would grow indefinitely, including all previous targets.
    updateTarget(agentID, startX, startY, targetX, targetY) {

            this.agent_id = `id_${agentID}`;
            this.objects += `me ${this.agent_id} `
            this.init = `(me ${this.agent_id})` + this.init0;

            this.startX = startX;
            this.startY = startY;
            this.init += `(at ${this.agent_id} t${this.startX}_${this.startY})`;

            this.targetX = targetX;
            this.targetY = targetY;
    }   


    generateProblemDefinition() {

        const goal = `at ${this.agent_id} t${this.targetX}_${this.targetY}`;
        console.log('Goal:', goal);

        var pddlProblem = new PddlProblem(
            'grid-path-planning',
            this.objects,
            this.init,
            goal
        )
        let problem = pddlProblem.toPddlString();
        return problem
      }
  

    async planAndExecute() {

        if (this.isPlanning) {
            console.log('A plan is already in execution. Please wait or cancel the current plan before starting a new one.');
            // here it woould be possible to drop the new plan or to queue it or to cancel the current one.
            return; // Exit if a plan is currently being executed
            }
        this.isPlanning = true; // Mark as planning started

        try {

            const problem = this.generateProblemDefinition();
            const plan = await onlineSolver(domain, problem);
            const pddlExecutor = new PddlExecutor(...executors);
            // await otherwise the plan is not executed because rest of the code is faster?
            await pddlExecutor.exec(plan);

        } catch (error) {
            console.error('Error during path planning:', error);
        } finally {
            this.isPlanning = false; // Reset planning state
        }
    }
}

const client = new DeliverooApi(
    'http://localhost:8080', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImJiNWJiNWEyYjA3IiwibmFtZSI6IlNWTSIsImlhdCI6MTcxMjY0OTM2NH0.trqXmE29PmO4AVgVWWZjSrxj4CqLS1pqk3aQnnSsl-4'
)

// pathPlanning is initialized. InitializeMap is called.
var pathPlanning;

function distance( {x:x1, y:y1}, {x:x2, y:y2}) {
    const dx = Math.abs( Math.round(x1) - Math.round(x2) )
    const dy = Math.abs( Math.round(y1) - Math.round(y2) )
    return dx + dy;
}
function nearestDelivery(x4, y4) {
    const distances = []
    const delivs = map1.deliv()
    for (const d of delivs){   
        distances.push(distance( {x:d.x, y:d.y}, {x:x4, y:y4}))
    }
    const minDistanceIndex = distances.indexOf(Math.min(...distances));
    return delivs[minDistanceIndex];
}


const me = { carrying: new Map()};
client.onYou( ( {id, name, x, y, score} ) => {
    me.id = id
    me.name = name
    me.x = x
    me.y = y
    me.score = score
} )

const map = {
    width:undefined,
    height:undefined,
    tiles: new Map(),
    add: function ( tile ) {
        const {x, y} = tile;
        return this.tiles.set( x+1000*y, tile );
    },
    xy: function (x, y) {
        return this.tiles.get( x+1000*y )
    },
    spwn: function () {
        return Array.from( this.tiles.values() ).filter( ({parcelSpawner}) => parcelSpawner )
    },
    deliv: function () {
        return Array.from( this.tiles.values() ).filter( ({delivery}) => delivery )
    },
    blkd: function () {
        return Array.from( this.tiles.values() ).filter( ({blocked}) => blocked )
    }
};

client.onMap( (width, height, tiles) => {
    map.width = width;
    map.height = height;
    for (const t of tiles) {
        map.add( t );
    }

    pathPlanning = new PathPlanning();

    const midpoint = map.width / 2;
    Array.from(map.tiles.values()).forEach(tile => {
    if (tile.x <= midpoint) {
        map1.add(tile);
    } else {
        map2.add(tile);
    }
    });

    if (multi_agents == 0 || split_map == 0) {map1 = map};


} )


client.onTile( (x, y, delivery) => {
    map.add( {x, y, delivery} );
} )

client.onNotTile( ( x, y ) => { 
    map.add( {x, y, blocked: true} );
} )

var map1 = {
    width: map.width,
    height: Math.ceil(map.height / 2),
    tiles: new Map(),
    add: map.add,
    xy: map.xy,
    spwn: map.spwn,
    deliv: map.deliv,
    blkd: map.blkd
};

var map2 = {
    width: map.width,
    height: Math.floor(map.height / 2),
    tiles: new Map(),
    add: map.add,
    xy: map.xy,
    spwn: map.spwn,
    deliv: map.deliv,
    blkd: map.blkd
};

var AGENTS_OBSERVATION_DISTANCE
var PARCELS_OBSERVATION_DISTANCE
var MOVEMENT_DURATION
var PARCEL_DECADING_INTERVAL

client.onConfig( (config) => {
    AGENTS_OBSERVATION_DISTANCE = config.AGENTS_OBSERVATION_DISTANCE;
    PARCELS_OBSERVATION_DISTANCE = config.PARCELS_OBSERVATION_DISTANCE;
    MOVEMENT_DURATION = config.MOVEMENT_DURATION;
    PARCEL_DECADING_INTERVAL = config.PARCEL_DECADING_INTERVAL//== '1s' ? 1000 : 1000000;
} );

const agents = new Map();
client.onAgentsSensing( ( sensed_agents ) => {
    for ( const {id, name, x, y, score} of sensed_agents ) {
        agents.set(id, {id, x, y} );
    }
    for ( const [id, {x, y}] of agents.entries() ) {
        if ( distance (me, {x, y}) < AGENTS_OBSERVATION_DISTANCE && ! sensed_agents.find( (sensed) => id == sensed.id ) )
        agents.delete(id);
    }
} );


client.onMsg( (id, name, msg, reply) => {

    if (msg.hello == 'parcel_spotted') {
        if (distance({x:msg.px,y:msg.py},{x:me.x,y:me.y}) <= msg.d) {
            reply(false);
        }
        else {
            reply(true);
        }
    }
    else if (msg.hello == 'distance_to') {
        if (distance({x:msg.x,y:msg.y},{x:me.x,y:me.y}) < msg.my_d) {
            reply(false);
        }
        else {
            reply(true);
        }
    }
    else if (msg.hello == 'go_to') {
        myAgent.push(['go_to_0',msg.x, msg.y]);
        }
});

const parcels = new Map();
client.onParcelsSensing( async ( perceived_parcels ) => {
    let new_parcel_sensed = false;
    for (const p of perceived_parcels) {
        if ( ! parcels.has(p.id) )
            new_parcel_sensed = true;
        parcels.set( p.id, p)
        if ( p.carriedBy == me.id ) {
            me.carrying.set( p.id, p );
        }
    }
    for ( const [id,p] of parcels.entries() ) {
        if ( ! perceived_parcels.find( p=>p.id==id ) ) {
            parcels.delete( id ); 
            me.carrying.delete( id );
        }
    }
} )

var reset1 = true;
var ignored_parcels = [];

client.onParcelsSensing( async(parcels) => {

    const options = []
    for (const parcel of parcels.values()) {

        //const d5 = []
        //for (const a of agents){
            //d5.push(distance({x:parcel.x,y:parcel.y},{x:a[1].x,y:a[1].y}))}
        // if ( ! parcel.carriedBy && distance({x:parcel.x,y:parcel.y},{x:me.x,y:me.y}) <= Math.min(...d5)) {
        // removed the condition on distance from agents. From challenge it was observed that was not good: 
        // agents are not moving, or standing still or if other agents have a similar behaviour, then the condition is not useful.
        
        var reply = true;
        if (multi_agents == 1 && isolated_single == 0){
            reply = await client.ask( '35d84ac07da', {
                px: parcel.x,
                py: parcel.y,
                pid: parcel.id,
                d: distance({x:parcel.x,y:parcel.y},{x:me.x,y:me.y}),
                hello: 'parcel_spotted',
                iam: client.name,
                id: client.id
            } );
        } else {
            reply = true;
        }

        if (map1.xy(parcel.x, parcel.y) == undefined){ignored_parcels.push(parcel.id)};
        if (me.carrying.size<4 && !parcel.carriedBy && reply && (!ignored_parcels.includes(parcel.id))) {
            options.push( [ 'go_pick_up', parcel.x, parcel.y, parcel.id]);
        }
    }

    // Options filtering
    let best_option;
    let nearest = Number.MAX_VALUE;
    for (const option of options) {
        if ( option[0] == 'go_pick_up' ) {
            let [go_pick_up,x,y,id] = option;
            let current_d = distance( {x, y}, me )
            if ( current_d < nearest ) {
                best_option = option
                nearest = current_d
            }
        }
    }

    // Best option is selected
    if ( best_option ){
        reset1 = true;
        myAgent.push( best_option );
    }
    else if (reset1){

        reset1 = false;
        if (me.carrying.size > 0){
            myAgent.push( ['deliv1', nearestDelivery(me.x,me.y).x, nearestDelivery(me.x,me.y).y])
        }
        else (when_idle === 1 ? myAgent.push( ['expl_rand', me.x, me.y]) : myAgent.push( ['standstill']));
    }
    else {
        reset1 = true;
    }
} )

const beliefset = new Map();

// Intention revision loop
class IntentionRevision {

    #intention_queue = new Array();
    get intention_queue () {
        return this.#intention_queue;
    }
    async loop ( ) {
        while ( true ) {
            
            // Consumes intention_queue if not empty
            if ( this.intention_queue.length > 0 ) {
                console.log( 'intentionRevision.loop', this.intention_queue.map(i=>i.predicate) );
                // Current intention
                const intention = this.intention_queue[0];
                // Is queued intention still valid? Do I still want to achieve it?
                let id = intention.predicate[2]
                let p = parcels.get(id)
                if ( p && p.carriedBy ) {
                    console.log( 'Skipping intention because no more valid', intention.predicate )
                    continue;
                }
                // Start achieving intention
                await intention.achieve()
                // Catch eventual error and continue
                .catch( error => {
                    // console.log( 'Failed intention', ...intention.predicate, 'with error:', ...error )
                } );
                // Remove from the queue
                this.intention_queue.shift();
            }
            // Postpone next iteration at setImmediate
            await new Promise( res => setImmediate( res ) );
        }
    }
    // async push ( predicate ) { }
    log ( ...args ) {
        console.log( ...args )
    }
}

class IntentionRevisionQueue extends IntentionRevision {

    async push ( predicate ) {
        // Check if already queued
        if ( this.intention_queue.find( (i) => i.predicate.join(' ') == predicate.join(' ') ) )
            return; // intention is already queued
        console.log( 'IntentionRevisionReplace.push', predicate );
        const intention = new Intention( this, predicate );
        this.intention_queue.push( intention );
    }
}

class IntentionRevisionReplace extends IntentionRevision {

    async push ( predicate ) {
        // Check if already queued
        const last = this.intention_queue.at( this.intention_queue.length - 1 );
        if ( last && last.predicate.join(' ') == predicate.join(' ') ) {
            return; // intention is already being achieved
        }
        console.log( 'IntentionRevisionReplace.push', predicate );
        const intention = new Intention( this, predicate );
        this.intention_queue.push( intention );
        // Force current intention stop 
        if ( last ) {
            last.stop();
        }
    }
}


// Start intention revision loop (choose one: queue or replace)
// const myAgent = new IntentionRevisionQueue();
const myAgent = new IntentionRevisionReplace();
myAgent.loop();


class Intention {
    // Plan currently used for achieving the intention 
    #current_plan;
    // This is used to stop the intention
    #stopped = false;
    get stopped () {
        return this.#stopped;
    }
    stop () {
        // this.log( 'stop intention', ...this.#predicate );
        this.#stopped = true;
        if ( this.#current_plan)
            this.#current_plan.stop();
    }
    /**#parent refers to caller*/
    #parent;
    /** predicate is in the form ['go_to', x, y]*/
    get predicate () {
        return this.#predicate;
    }
    #predicate;

    constructor ( parent, predicate ) {
        this.#parent = parent;
        this.#predicate = predicate;
    }
    log ( ...args ) {
        if ( this.#parent && this.#parent.log )
            this.#parent.log( '\t', ...args )
        else
            console.log( ...args )
    }
    #started = false;
    /*** Using the plan library to achieve an intention*/
    async achieve () {
        // Cannot start twice
        if ( this.#started)
            return this;
        else
            this.#started = true;
        // Trying all plans in the library
        for (const planClass of planLibrary) {
            // if stopped then quit
            if ( this.stopped ) throw [ 'stopped intention', ...this.predicate ];
            // if plan is 'statically' applicable
            if ( planClass.isApplicableTo( ...this.predicate ) ) {
                // plan is instantiated
                this.#current_plan = new planClass(this.parent);
                this.log('achieving intention', ...this.predicate, 'with plan', planClass.name);
                // and plan is executed and result returned
                try {
                    const plan_res = await this.#current_plan.execute( ...this.predicate );
                    this.log( 'succesful intention', ...this.predicate, 'with plan', planClass.name, 'with result:', plan_res );
                    return plan_res
                // or errors are caught so to continue with next plan
                } catch (error) {
                    this.log( 'failed intention', ...this.predicate,'with plan', planClass.name, 'with error:', ...error );
                }
            }
        }
        // if stopped then quit
        if ( this.stopped ) throw [ 'stopped intention', ...this.predicate ];
        // no plans have been found to satisfy the intention
        // this.log( 'no plan satisfied the intention ', ...this.predicate );
        reset1 = true;
        this.#current_plan.stop();;
        throw ['no plan satisfied the intention ', ...this.predicate ];
    }
}

// Plan library
const planLibrary = [];
class Plan {
    // This is used to stop the plan
    #stopped = false;
    stop () {
        // this.log( 'stop plan' );
        this.#stopped = true;
        for ( const i of this.#sub_intentions ) {
            i.stop();
        }
    }
    get stopped () {
        return this.#stopped;
    }
    /*** #parent refers to caller*/
    #parent;
    constructor ( parent ) {
        this.#parent = parent;
    }
    log ( ...args ) {
        if ( this.#parent && this.#parent.log )
            this.#parent.log( '\t', ...args )
        else
            console.log( ...args )
    }
    // this is an array of sub intention. Multiple ones could eventually being achieved in parallel.
    #sub_intentions = [];
    async subIntention ( predicate ) {
        const sub_intention = new Intention( this, predicate );
        this.#sub_intentions.push( sub_intention );
        return await sub_intention.achieve();
    }
}




//
// Here we define the various plans:
//

class IsolatedSectionSingle extends Plan {

    static isApplicableTo ( isolated_section, isolated_section2 ) {
        return isolated_section == 'isolated_section_single';
    }
    async execute (isolated_section, isolated_section2) {

        console.log('Agent1 stucked in this IsolatedSection', isolated_section2);
        
        const keysToDelete = [];
        var map_temp = map;
        for (const [key, tile] of map_temp.tiles.entries()) {
          const isInIsolatedSection = isolated_section2.some(coord => coord[0] === tile.x && coord[1] === tile.y);
          if (!isInIsolatedSection) {
            keysToDelete.push(key);
          }
        }
        keysToDelete.forEach(key => map_temp.tiles.delete(key));
        map1 = map_temp;
        return true;
    }
}

var base_x;
var base_y;
class IsolatedSection extends Plan {

    static isApplicableTo ( isolated_section, isolated_section2 ) {
        return isolated_section == 'isolated_section';
    }
    async execute (isolated_section, isolated_section2) {

        console.log('We are both stucked in this IsolatedSection', isolated_section2);
        
        const keysToDelete = [];
        var map_temp = map;
        for (const [key, tile] of map_temp.tiles.entries()) {
          const isInIsolatedSection = isolated_section2.some(coord => coord[0] === tile.x && coord[1] === tile.y);
          if (!isInIsolatedSection) {
            keysToDelete.push(key);
          }
        }
        keysToDelete.forEach(key => map_temp.tiles.delete(key));
        map1 = map_temp;

        var l = (isolated_section2.length) - 1;
        var c1x = isolated_section2[0][0];
        var c1y = isolated_section2[0][1];
        var c2x = isolated_section2[l][0];
        var c2y = isolated_section2[l][1];

        var reply;
        if (multi_agents == 1){
            reply = await client.ask( '35d84ac07da', {
                hello: 'distance_to_low1',
                x: c1x,
                y: c1y,
                x2: c2x,
                y2: c2y,
                my_d: distance({x:c1x,y:c1y},{x:me.x,y:me.y}),
            } );
        } else {
            reply = false;
        }

        if (reply) {
            base_x = c1x;
            base_y = c1y;
            console.log('agent1 - base_x:', base_x, 'base_y:', base_y);
        } else {
            base_x = c2x;
            base_y = c2y;
            console.log('agent1 - base_x:', base_x, 'base_y:', base_y);
        }

        console.log('substituing GoDeliver with GoDeliver2 in planLibrary');
        planLibrary.unshift( GoDeliver2 );
        return true;
    }
}


class GoDeliver2 extends Plan {

    static isApplicableTo ( go_deliv2, x, y,) {
        return go_deliv2 == 'deliv1';
    }
    async execute ( go_deliv2, x, y ) {
        if ( this.stopped ) {reset1=true; throw ['stopped'];}

        let randomIndex = Math.floor(Math.random() * map1.deliv().length);
        let selectedPoint = map1.deliv()[randomIndex];
        var x_r = selectedPoint.x;
        var y_r = selectedPoint.y;

        var reply;
        if (multi_agents == 1){
            reply = await client.ask( '35d84ac07da', {
                hello: 'distance_to',
                x: x_r,
                y: y_r,
                my_d: distance({x:x_r,y:y_r},{x:me.x,y:me.y})
            } );
        } else {
            reply = false;
        }

        if (reply) {
            if ( this.stopped ) {reset1=true; throw ['stopped'];}
            await this.subIntention( ['go_to', x_r, y_r] );
            await client.putdown();
            if ( this.stopped ) {reset1=true; throw ['stopped'];}
            reset1=true;
            return true;
        }

        else {
            if ( this.stopped ) {reset1=true; throw ['stopped'];}
            console.log(me.carrying.keys());
            for (let pid of me.carrying.keys()){
                console.log('pid:', pid);
                ignored_parcels.push(pid);
                }

            await client.putdown();
            await this.subIntention( ['go_to', base_x, base_y] );

            await client.say( '35d84ac07da', {
                hello: 'go_to',
                x: base_x,
                y: base.y,
            } );

            if ( this.stopped ) {reset1=true; throw ['stopped'];}
            reset1=true;
            return true;
        }
    }
}


class GoTo extends Plan {

    static isApplicableTo ( go_to_0, x, y) {
        return go_to_0 == 'go_to_0';
    }
    async execute ( go_to_0, x, y ) {
        if ( this.stopped ) throw ['stopped'];
        await this.subIntention( ['go_to', x, y] );
        if ( this.stopped ) throw ['stopped'];
        return true;
    }
}

class GoPickUp extends Plan {

    static isApplicableTo ( go_pick_up, x, y, id ) {
        return go_pick_up == 'go_pick_up';
    }
    async execute ( go_pick_up, x, y ) {
        if ( this.stopped ) throw ['stopped'];
        await this.subIntention( ['go_to', x, y] );
        if ( this.stopped ) throw ['stopped'];
        await client.pickup();
        await client.pickup();
        if ( this.stopped ) throw ['stopped'];
        return true;
    }
}

class GoDeliver extends Plan {

    static isApplicableTo ( go_deliv1, x, y,) {
        return go_deliv1 == 'deliv1';
    }
    async execute ( go_deliv1, x, y ) {
        if ( this.stopped ) {reset1=true; throw ['stopped'];}
        await this.subIntention( ['go_to', x, y] );
        await client.putdown();
        if ( this.stopped ) {reset1=true; throw ['stopped'];}
        reset1=true;
        return true;
    }
}

// use_pddl == 0 will use the BlindMove, == 1 will use the PDDL_Move.
class PDDL_Move extends Plan {

    static isApplicableTo ( pddl_move, x, y ) {
        return pddl_move == (use_pddl === 1 ? 'go_to' : 'go_to2');
    }

    async execute ( pddl_move, x, y ) {

        // Round x and y to the closest integer because otherwise they wouldn't match the tile names in pddl objects.
        console.log('PDDL_Move', 'from', Math.round(me.x), Math.round(me.y), 'to', Math.round(x), Math.round(y));
        pathPlanning.updateTarget(me.id, Math.round(me.x), Math.round(me.y), Math.round(x), Math.round(y));
        await pathPlanning.planAndExecute();

        return true; 
    }
    
}

// BlindMove + simple backtracking mechanism to avoid getting stuck.
class BlindMove extends Plan {

    static isApplicableTo ( go_to, x, y ) {
        return go_to == (use_pddl === 0 ? 'go_to' : 'go_to2');
    }

    async execute ( go_to, x, y ) {

        while ( me.x != x || me.y != y ) {
            if ( this.stopped ) throw ['stopped']; 
            let status_x = false;
            let status_y = false; 
            if ( x > me.x ){
                status_x = await client.move('right');
            }
            else if ( x < me.x ){
                status_x = await client.move('left');   
            }      
            if (status_x) {
                me.x = status_x.x;
                me.y = status_x.y;
            }
            if ( this.stopped ) throw ['stopped'];
            if ( y > me.y )
                status_y = await client.move('up')
            else if ( y < me.y )
                status_y = await client.move('down')
            if (status_y) {
                me.x = status_y.x;
                me.y = status_y.y;
            }      
            if ( ! status_x && ! status_y) {
                await this.backtrack();
            } else if ( me.x == x && me.y == y ) {
                console.log('target reached');
            }          
        }
        return true;
    }

    // simple backtracking mechanism introduced to avoid getting stuck:
    // it will perform n (=10) random moves and then continue with the original path.
    async backtrack() {
        console.log('BACKTRACKING')
        for (let i = 0; i < 10; i++) {
            const d = ['right', 'left', 'up', 'down'][Math.floor(Math.random() * 4)];
            await client.move(d);
          }
        // Continue with the original path
        await this.execute(go_to, x, y);
    }
}


class ExplRandom extends Plan {

    static isApplicableTo ( expl_rand, x, y, id ) {
        return expl_rand == 'expl_rand';
    }
    async execute ( expl_rand, x, y ) {

        var x_r0 = Math.floor(Math.random() * (map.width-1));
        var y_r0 = Math.floor(Math.random() * (map.height-1));
        if (map1.spwn().length < 1){return this.subIntention( ['go_to', x_r0, y_r0] );}

        // --> if there is at least one, it picks a random spawnable tile (possible to add closer spawnable tile or other conditions)
        // in the agent's half of the map
        let randomIndex = Math.floor(Math.random() * map1.spwn().length);
        let selectedPoint = map1.spwn()[randomIndex];
        var x_r = selectedPoint.x;
        var y_r = selectedPoint.y;

        while( x_r == me.x && y_r == me.y ){
            // the camping cross
            if (map1.spwn().length < 2){
                await client.move('right');
                await client.move('left');
                await client.move('up');
                await client.move('down');
                await client.move('left');
                await client.move('right'); 
                await client.move('down');
                await client.move('up');
            }
            let randomIndex = Math.floor(Math.random() * map1.spwn().length);
            let selectedPoint = map1.spwn()[randomIndex];
            x_r = selectedPoint.x;
            y_r = selectedPoint.y;
        }

        console.log('ExplRandom:', 'from' , me.x, me.y, 'to', x_r, y_r);

        if ( this.stopped ) throw ['stopped'];
        await this.subIntention( ['go_to', x_r, y_r] );
        if ( this.stopped ) throw ['stopped'];
        await client.pickup()
        if ( this.stopped ) throw ['stopped'];
        return true;
    }
}

// ExplFar3 is a plan that will move the agent to the farthest corner of the map. Currently not used
class ExplFar3 extends Plan {

    static isApplicableTo ( expl3, xm, ym ) {
        return expl3 == 'expl3';
    }
    async execute ( expl3, xm, ym ) {

        var c_xmax = map.width-1;
        var c_ymax = map.height-1;
        var values6 = {
        c1 : distance( {x:0, y:0}, {x:xm, y:ym}),
        c2 : distance( {x:0, y:c_ymax}, {x:xm, y:ym} ),
        c3 : distance( {x:c_xmax, y:0}, {x:xm, y:ym} ),
        c4 : distance( {x:c_xmax, y:c_ymax}, {x:xm, y:ym} )
        }
        const maxValueName = Object.keys(values6).reduce((maxName, currentName) => {
             return values6[maxName] > values6[currentName] ? maxName : currentName;
             }, '');   
        var values7 = {
        c1 : [0,0],
        c2 : [0,c_ymax],
        c3 : [c_xmax,0],
        c4 : [c_xmax,c_ymax]
        }
        var x2 = values7[maxValueName][0];
        var y2 = values7[maxValueName][1];

        if ( this.stopped ) {reset1=true; throw ['stopped'];}
        await this.subIntention( ['go_to', x2, y2] );
        await client.putdown();
        if ( this.stopped ) {reset1=true; throw ['stopped'];}
        reset1 = true;
        prev_expl_p = [xm,ym]
        return true;
    }
}


// perform a random different move
class RandomMove extends Plan {
    static isApplicableTo ( random1) {
        return random1 == 'random1';
    }
    async execute () {
        let tried = [];
        var previous = 'right';
        while ( tried.length < 4 ) {
            let current = { up: 'down', right: 'left', down: 'up', left: 'right' }[previous] // backward
            if ( tried.length < 3 ) { // try ahead or turn (before going backward)
                //current = [ 'up', 'right', 'down', 'left' ].filter( d => d != current )[ Math.floor(Math.random()*3) ];
                current = [ 'up', 'right', 'down', 'left' ][ Math.floor(Math.random()*4) ];
                //this way it goes full randomS
            }
            if ( ! tried.includes(current) ) {  
                if ( await client.move( current ) ) {
                    console.log( 'moved', current );
                    previous = current;
                    break; // moved, continue
                }   
                tried.push( current );   
            }  
        }
        if ( tried.length == 4 ) {
            console.log( 'stucked' );
            await client.timer(1000); // stucked, wait 1 sec and retry
        } 
        return true;
    }
}


// StandStill is a plan that will make the agent stand still for 1 second and then retry to move
class StandStill extends Plan {
    static isApplicableTo ( standstill, ms) {
        return standstill == 'standstill';
    }
    async execute (standstill, ms) {
        await new Promise(async(resolve) => setTimeout(resolve, 1));
        return true;
    }
}


// Plan classes are added to plan library 
planLibrary.push( GoTo )

planLibrary.push( GoPickUp )
planLibrary.push( BlindMove )
planLibrary.push( RandomMove )
planLibrary.push( GoDeliver )
planLibrary.push( ExplFar3 )
planLibrary.push( ExplRandom )
planLibrary.push( StandStill )
planLibrary.push( PDDL_Move )

planLibrary.push( IsolatedSectionSingle )
planLibrary.push( IsolatedSection )

